package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"log/slog"
	"net/http"

	"connectrpc.com/connect"
	"connectrpc.com/validate"
	"connectrpc.com/vanguard"
	greetv1 "github.com/lao-tseu-is-alive/connect-go-example/gen/greet/v1"        // generated by protoc-gen-go
	"github.com/lao-tseu-is-alive/connect-go-example/gen/greet/v1/greetv1connect" // generated by protoc-gen-connect-go
	"github.com/lao-tseu-is-alive/go-cloud-k8s-common-libs/pkg/config"
	"github.com/lao-tseu-is-alive/go-cloud-k8s-common-libs/pkg/golog"
	"github.com/rs/cors"
)

const (
	APP             = "greetServer"
	VERSION         = "0.0.5"
	AppVersion      = APP + " v" + VERSION
	defaultIp       = "127.0.0.1"
	defaultPort     = 8080
	defaultLogName  = "stderr"
	myHeaderKey     = "Acme-Tenant-Id"
	serverHeaderKey = "App-Version"
)

type GreetServer struct {
	Logger          *slog.Logger
	ClientHeaderKey string
}

func (s *GreetServer) Greet(ctx context.Context, req *greetv1.GreetRequest) (*greetv1.GreetResponse, error) {
	s.Logger.Info("entering Greet", "context", ctx, "request", req)
	if err := ctx.Err(); err != nil {
		return nil, err // automatically coded correctly
	}
	// let's retrieve client headers if any
	callInfo, ok := connect.CallInfoForHandlerContext(ctx)
	if !ok {
		return nil, errors.New("can't access headers: no CallInfo for handler context")
	}
	headerVal := callInfo.RequestHeader().Get(s.ClientHeaderKey)
	s.Logger.Info("retrieving special header", "headerKey", s.ClientHeaderKey, "headerValue", headerVal)

	res := &greetv1.GreetResponse{
		Greeting: fmt.Sprintf("Hello, %s!", req.Name),
	}
	//let's send back a server header
	callInfo.ResponseHeader().Set(serverHeaderKey, AppVersion)
	return res, nil
}

func main() {
	logWriter, err := config.GetLogWriter(defaultLogName)
	if err != nil {
		log.Fatalf("ðŸ’¥ðŸ’¥ error getting log writer: %v'\n", err)
	}
	logLevel, err := config.GetLogLevel(golog.InfoLevel)
	if err != nil {
		log.Fatalf("ðŸ’¥ðŸ’¥ error getting log level: %v'\n", err)
	}
	l := golog.NewLogger("simple", logWriter, logLevel, APP)
	l.Info("ðŸš€ Starting", "app", APP, "version", VERSION)

	greeter := &GreetServer{Logger: l, ClientHeaderKey: myHeaderKey}

	// Create the Connect handler with validation interceptor
	path, handler := greetv1connect.NewGreetServiceHandler(
		greeter,
		// Validation via Protovalidate is almost always recommended
		connect.WithInterceptors(validate.NewInterceptor()),
	)

	// Wrap with Vanguard for REST transcoding support
	// This enables REST-style URLs like GET /v1/greet/{name} and POST /v1/greet
	service := vanguard.NewService(path, handler)
	transcoder, err := vanguard.NewTranscoder([]*vanguard.Service{service})
	if err != nil {
		log.Fatalf("ðŸ’¥ðŸ’¥ error creating vanguard transcoder: %v'\n", err)
	}

	// 3. Use a Mux to route traffic
	mux := http.NewServeMux()
	// Explicitly mount the Connect handler for RPC traffic (bypasses Vanguard)
	//  Any request starting with /greet.v1.GreetService/ is routed directly to the generated Connect handler.
	// This handler accepts simple JSON requests like:
	// curl -s -H "Content-Type: application/json" -d '{"name": "Carlitos"}' http://localhost:8080/greet.v1.GreetService/Greet |jq
	// without requiring extra headers for Connect protocol -H "Connect-Protocol-Version: 1"
	mux.Handle(path, handler)
	// Mount Vanguard for everything else (REST transcoding)
	mux.Handle("/", transcoder)

	// Configure CORS to allow the headers Connect/gRPC-Web needs
	corsHandler := cors.New(cors.Options{
		AllowedOrigins: []string{"http://localhost:5173"}, // Vite default port
		AllowedMethods: []string{
			http.MethodGet,
			http.MethodPost,
			http.MethodOptions,
		},
		AllowedHeaders: []string{
			"Accept-Encoding",
			"Content-Encoding",
			"Content-Type",
			"Connect-Protocol-Version",
			"Connect-Timeout-Ms",
			"Connect-Accept-Encoding",
			"Content-Length",
			"Grpc-Timeout",
			"X-Grpc-Web",
			"X-User-Agent",
			myHeaderKey,     // Your custom header
			serverHeaderKey, // Your custom header
		},
		ExposedHeaders: []string{
			"Grpc-Status",
			"Grpc-Message",
			"Grpc-Status-Details-Bin",
			serverHeaderKey, // Expose your custom header to the browser
		},
	})

	p := new(http.Protocols)
	p.SetHTTP1(true)
	// Use h2c so we can serve HTTP/2 without TLS.
	p.SetUnencryptedHTTP2(true)
	serverAddress := fmt.Sprintf("%s:%d", defaultIp, defaultPort)
	l.Info("Will start server ...", "listenAddress", serverAddress)
	l.Info("REST endpoints available:", "GET", "/v1/greet/{name}", "POST", "/v1/greet")
	l.Info("Connect endpoints available:", "POST", "/greet.v1.GreetService/Greet")
	s := http.Server{
		Addr: serverAddress,
		//Handler:   transcoder, // Use transcoder instead of mux to block classic connect url
		Handler:   corsHandler.Handler(mux), // <--- Use mux instead of transcoder to allow POST /greet.v1.GreetService/Greet
		Protocols: p,
	}
	err = s.ListenAndServe()
	if err != nil {
		l.Error("error doing ListenAndServe", "error", err)
		return
	}
}
