package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"log"
	"log/slog"
	"net/http"
	"time"

	"connectrpc.com/connect"
	"github.com/google/uuid"
	greetv1 "github.com/lao-tseu-is-alive/connect-go-example/gen/greet/v1"        // generated by protoc-gen-go
	"github.com/lao-tseu-is-alive/connect-go-example/gen/greet/v1/greetv1connect" // generated by protoc-gen-connect-go
	"github.com/lao-tseu-is-alive/go-cloud-k8s-common-libs/pkg/config"
	"github.com/lao-tseu-is-alive/go-cloud-k8s-common-libs/pkg/golog"
)

const (
	APP             = "greetClient"
	VERSION         = "0.0.3"
	defaultName     = "connectRPC"
	defaultIp       = "127.0.0.1"
	defaultPort     = 8080
	defaultLogName  = "stderr"
	myHeaderKey     = "Acme-Tenant-Id"
	serverHeaderKey = "App-Version"
)

func main() {
	// Define flags
	bench := flag.Bool("bench", false, "Run benchmark")
	mode := flag.String("mode", "connect", "Protocol to use: 'connect', 'grpc', or 'json'")
	numMsgs := flag.Int("n", 1000, "Number of messages to send in benchmark mode")
	nameArg := flag.String("name", defaultName, "Name to greet")
	flag.Parse()

	logWriter, err := config.GetLogWriter(defaultLogName)
	if err != nil {
		log.Fatalf("ðŸ’¥ðŸ’¥ error getting log writer: %v'\n", err)
	}
	logLevel, err := config.GetLogLevel(golog.InfoLevel)
	if err != nil {
		log.Fatalf("ðŸ’¥ðŸ’¥ error getting log level: %v'\n", err)
	}
	l := golog.NewLogger("simple", logWriter, logLevel, APP)
	l.Info("ðŸš€ Starting", "app", APP, "version", VERSION)

	// Determine name to greet (flag takes precedence, then args if any, then default)
	nameToGreet := *nameArg
	if nameToGreet == defaultName && len(flag.Args()) > 0 {
		nameToGreet = flag.Args()[0]
	}

	serverAddress := fmt.Sprintf("%s:%d", defaultIp, defaultPort)
	l.Info("Will call Greet to server", "listenAddress", serverAddress, "name", nameToGreet, "mode", *mode)

	reqUrl := fmt.Sprintf("http://%s", serverAddress)

	var opts []connect.ClientOption
	switch *mode {
	case "grpc":
		opts = append(opts, connect.WithGRPC())
	case "json":
		opts = append(opts, connect.WithProtoJSON())
	case "connect":
		// Default: Connect protocol with Protobuf encoding (no options needed)
	default:
		l.Error("received invalid mode. use 'connect', 'grpc', or 'json'", "mode", *mode)
	}

	client := greetv1connect.NewGreetServiceClient(
		http.DefaultClient,
		reqUrl,
		opts...,
	)

	if *bench {
		runBenchmark(client, *numMsgs, nameToGreet, l)
	} else {
		// let's add some header for the server
		id := uuid.NewString()
		ctx, callInfo := connect.NewClientContext(context.Background())

		callInfo.RequestHeader().Set(myHeaderKey, id)
		res, err := client.Greet(
			ctx,
			&greetv1.GreetRequest{Name: nameToGreet},
		)
		if err != nil {
			fmt.Println(connect.CodeOf(err))
			if connectErr := new(connect.Error); errors.As(err, &connectErr) {
				l.Error("connect error doing client.Greet", "message", connectErr.Message(), "details", connectErr.Details())
			}
			l.Error("error doing client.Greet", "error", err)
			return
		}
		serverHeaderValue := callInfo.ResponseHeader().Get(serverHeaderKey)
		l.Info("received header from server", "headerKey", serverHeaderKey, "headerValue", serverHeaderValue)
		l.Info("received result from Greet call", "result", res.Greeting)
	}
}

func runBenchmark(client greetv1connect.GreetServiceClient, n int, name string, l *slog.Logger) {
	l.Info("Starting benchmark", "n", n, "name", name)
	start := time.Now()
	for i := 0; i < n; i++ {
		_, err := client.Greet(
			context.Background(),
			&greetv1.GreetRequest{Name: name},
		)
		if err != nil {
			log.Fatalf("Benchmark failed at request %d: %v", i, err)
		}
	}
	elapsed := time.Since(start)
	seconds := elapsed.Seconds()
	rps := float64(n) / seconds
	l.Info("Benchmark finished", "elapsed", elapsed, "rps", fmt.Sprintf("%.2f", rps))
	fmt.Printf("Benchmark: %d messages in %v | RPS: %.2f\n", n, elapsed, rps)
}
